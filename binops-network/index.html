<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Signal color variables - easily customizable */
        :root {
            --active-one-color: #f00; /* Red for 1s */
            --active-zero-color: #0066cc; /* Blue for 0s */
            --hover-highlight-color: #ff9900; /* Orange for hover highlight */
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h1, h2 {
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .input-section {
            margin-bottom: 20px;
        }
        #networkJson {
            width: 100%;
            height: 120px;
            font-family: monospace;
            padding: 8px;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .network-visualization {
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 20px;
            overflow-x: auto;
        }
        #networkGraph {
            min-height: 500px;
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node circle.input {
            fill: #a8d5e5;
        }
        .node circle.hidden {
            fill: #e5d5a8;
        }
        .node circle.output {
            fill: #a8e5c3;
        }
        .node text {
            font-size: 12px;
            font-weight: bold;
        }
        .label {
            font-size: 10px;
            font-style: italic;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        .active-node-one {
            stroke: var(--active-one-color) !important;
            stroke-width: 3px !important;
        }
        .active-node-zero {
            stroke: var(--active-zero-color) !important;
            stroke-width: 3px !important;
        }
        .active-link-one {
            stroke: var(--active-one-color) !important;
            stroke-width: 2.5px !important;
            stroke-opacity: 1 !important;
        }
        .active-link-zero {
            stroke: var(--active-zero-color) !important;
            stroke-width: 2.5px !important;
            stroke-opacity: 1 !important;
        }
        
        .active-node, .active-link {
            display: none;
        }
        .input-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .input-group {
            display: flex;
            align-items: center;
        }
        .value-display {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
        }
        .controls {
            margin: 20px 0;
        }
        .layer-label {
            text-anchor: middle;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Add hover highlight styles */
        .hover-highlight-node {
            stroke: var(--hover-highlight-color) !important;
            stroke-width: 4px !important;
        }
        
        .hover-highlight-link {
            stroke: var(--hover-highlight-color) !important;
            stroke-width: 3px !important;
            stroke-opacity: 0.8 !important;
        }
        
        .hover-highlight-related-node {
            stroke: var(--hover-highlight-color) !important;
            stroke-width: 2px !important;
        }
        
        /* Tooltip for showing neuron info */
        .tooltip {
            position: absolute;
            padding: 6px 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Test data validation table styles */
        .test-data-section {
            margin-top: 30px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        
        #testDataJson {
            width: 100%;
            height: 80px;
            font-family: monospace;
            padding: 8px;
        }
        
        .validation-table {
            margin-top: 20px;
            width: 100%;
            border-collapse: collapse;
        }
        
        .validation-table th, .validation-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .validation-table th {
            background-color: #f2f2f2;
        }
        
        .validation-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .validation-table .error {
            background-color: #ffcccb;
            font-weight: bold;
        }
        
        .validation-table .correct {
            background-color: #d6f5d6;
        }
        
        .validation-summary {
            margin-top: 15px;
            font-weight: bold;
            font-size: 16px;
        }

        /* Confusion matrix styles */
        .confusion-matrix-container {
            margin-top: 20px;
            margin-bottom: 30px;
        }
        
        .confusion-matrix {
            border-collapse: collapse;
            margin: 0 auto;
            text-align: center;
        }
        
        .confusion-matrix th, .confusion-matrix td {
            border: 1px solid #666;
            padding: 10px 15px;
        }
        
        .confusion-matrix th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .confusion-matrix .highlight-cell {
            background-color: #e8e8e8;
        }
        
        .confusion-matrix .true-positive {
            background-color: #d0f0d0;
        }
        
        .confusion-matrix .false-positive {
            background-color: #f8d0d0;
        }
        
        .confusion-matrix .false-negative {
            background-color: #f0e0c0;
        }
        
        .confusion-matrix .true-negative {
            background-color: #d0e0f0;
        }
        
        .metrics-table {
            width: auto;
            margin: 20px auto;
            border-collapse: collapse;
        }
        
        .metrics-table th, .metrics-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        
        .metrics-table th {
            background-color: #f2f2f2;
        }
        
        .single-output-metrics {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Neural Network Visualizer</h1>
        
        <div class="input-section">
            <h2>Network Configuration</h2>
            <textarea id="networkJson" placeholder="Paste JSON representation of the network here..."></textarea>
            <div>
                <button id="visualizeBtn">Visualize Network</button>
                <button id="sampleBtn">Load Sample</button>
            </div>
        </div>
        
        <div id="networkControls" style="display: none;">
            <h2>Network Inputs</h2>
            <div id="inputControls" class="input-controls"></div>
            <div class="controls">
                <button id="runBtn">Run Network</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
        
        <div class="network-visualization">
            <h2>Network Visualization</h2>
            <div id="networkGraph"></div>
        </div>
        
        <!-- Add test data validation section -->
        <div class="test-data-section">
            <h2>Test Data Validation</h2>
            <div class="input-section">
                <textarea id="testDataJson" placeholder="Paste test data JSON here (e.g. {'data': [{'input': [0,0,0], 'expected_output': [0,0]}, ...]}"></textarea>
                <div>
                    <button id="loadTestDataBtn">Load Test Data</button>
                    <button id="sampleTestDataBtn">Load Sample Test Data</button>
                </div>
            </div>
            <div id="validationResults" style="display: none;">
                <h3>Validation Results</h3>
                
                <!-- Add Single-Output Metrics (Confusion Matrix) -->
                <div id="singleOutputMetrics" class="single-output-metrics">
                    <h4>Confusion Matrix</h4>
                    <div class="confusion-matrix-container">
                        <table class="confusion-matrix">
                            <tr>
                                <th colspan="2" rowspan="2"></th>
                                <th colspan="2">Predicted</th>
                            </tr>
                            <tr>
                                <th>Positive (1)</th>
                                <th>Negative (0)</th>
                            </tr>
                            <tr>
                                <th rowspan="2">Actual</th>
                                <th>Positive (1)</th>
                                <td id="truePositives" class="true-positive">0</td>
                                <td id="falseNegatives" class="false-negative">0</td>
                            </tr>
                            <tr>
                                <th>Negative (0)</th>
                                <td id="falsePositives" class="false-positive">0</td>
                                <td id="trueNegatives" class="true-negative">0</td>
                            </tr>
                        </table>
                    </div>
                    
                    <h4>Classification Metrics</h4>
                    <table class="metrics-table">
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Accuracy</td>
                            <td id="accuracyMetric">0%</td>
                            <td>(TP + TN) / Total</td>
                        </tr>
                        <tr>
                            <td>Precision</td>
                            <td id="precisionMetric">0%</td>
                            <td>TP / (TP + FP)</td>
                        </tr>
                        <tr>
                            <td>Recall (Sensitivity)</td>
                            <td id="recallMetric">0%</td>
                            <td>TP / (TP + FN)</td>
                        </tr>
                        <tr>
                            <td>Specificity</td>
                            <td id="specificityMetric">0%</td>
                            <td>TN / (TN + FP)</td>
                        </tr>
                        <tr>
                            <td>F1 Score</td>
                            <td id="f1ScoreMetric">0</td>
                            <td>2 * (Precision * Recall) / (Precision + Recall)</td>
                        </tr>
                    </table>
                </div>
                
                <div class="validation-summary" id="validationSummary"></div>
                <table class="validation-table" id="validationTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Input</th>
                            <th>Expected Output</th>
                            <th>Actual Output</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="validationTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let network = null;
        let nodeData = [];
        let linkData = [];
        let simulationRunning = false;

        // Sample network JSON
        const sampleNetwork = {
            "input_size": 3,
            "layers": [
                {
                    "input_size": 3,
                    "neurons": [
                        {"operation": "Xor", "arguments_indexes": [0, 1]},
                        {"operation": "NoOp", "arguments_indexes": [1]},
                        {"operation": "Xor", "arguments_indexes": [0, 2]}
                    ]
                },
                {
                    "input_size": 3,
                    "neurons": [
                        {"operation": "Xor", "arguments_indexes": [1, 2]},
                        {"operation": "Or", "arguments_indexes": [0, 2]}
                    ]
                },
                {
                    "input_size": 2,
                    "neurons": [
                        {"operation": "Xor", "arguments_indexes": [0, 1]},
                        {"operation": "NoOp", "arguments_indexes": [0]}
                    ]
                }
            ]
        };

        // Event listeners
        document.getElementById('visualizeBtn').addEventListener('click', visualizeNetwork);
        document.getElementById('sampleBtn').addEventListener('click', loadSample);
        document.getElementById('runBtn').addEventListener('click', runSimulation);
        document.getElementById('resetBtn').addEventListener('click', resetVisualization);

        function loadSample() {
            document.getElementById('networkJson').value = JSON.stringify(sampleNetwork, null, 2);
        }

        function visualizeNetwork() {
            // Parse the JSON input
            const jsonInput = document.getElementById('networkJson').value;
            try {
                network = JSON.parse(jsonInput);
                renderNetwork(network);
                setupInputControls(network.input_size);
                document.getElementById('networkControls').style.display = 'block';
            } catch (error) {
                alert('Error parsing JSON: ' + error.message);
            }
        }

        function renderNetwork(network) {
            // Clear previous visualization
            document.getElementById('networkGraph').innerHTML = '';
            
            // Setup dimensions - make width dynamic based on number of layers
            const minWidth = d3.select('#networkGraph').node().getBoundingClientRect().width - 2; // Minimum width
            
            const minWidthPerLayer = 100; // Width per layer
            const totalLayersCount = network.layers.length + 1; // Input layer + hidden/output layers
            
            const widthPerLayer = Math.max(minWidthPerLayer, minWidth / network.layers.length - 30);
            const calculatedWidth = Math.max(minWidth, totalLayersCount * widthPerLayer);

            const width = calculatedWidth;
            
            // Calculate the largest layer size to determine height
            const layerSizes = [network.input_size];
            network.layers.forEach(layer => {
                layerSizes.push(layer.neurons.length);
            });
            const maxLayerSize = Math.max(...layerSizes);
            
            // Set a dynamic height with a minimum of 500px and at least 80px per node
            const minHeight = 500;
            const heightPerNode = 80;
            const calculatedHeight = Math.max(minHeight, maxLayerSize * heightPerNode);
            const height = calculatedHeight;
            
            const margin = { top: 40, right: 50, bottom: 30, left: 50 };
            const contentWidth = width - margin.left - margin.right;
            const contentHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select('#networkGraph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Add a group for the network
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);
            
            // Add layer labels
            g.append('text')
                .attr('class', 'layer-label')
                .attr('x', 0)
                .attr('y', -20)
                .text('Input Layer');
                
            // Calculate layers
            const totalLayers = network.layers.length + 1; // Input layer + hidden/output layers
            const layerSpacing = contentWidth / totalLayers;
            
            // Prepare data structures for nodes and links
            nodeData = [];
            linkData = [];
            
            // Add input layer nodes
            const inputNodes = [];
            const inputNodeSpacing = contentHeight / (network.input_size + 1);
            
            for (let i = 0; i < network.input_size; i++) {
                const nodeId = `input-${i}`;
                const node = {
                    id: nodeId,
                    x: 0,
                    y: (i + 1) * inputNodeSpacing,
                    layer: 0,
                    index: i,
                    type: 'input',
                    label: `Input ${i}`,
                    value: null
                };
                inputNodes.push(node);
                nodeData.push(node);
            }
            
            // Process each layer
            let prevLayerNodes = inputNodes;
            
            network.layers.forEach((layer, layerIndex) => {
                const layerType = layerIndex === network.layers.length - 1 ? 'output' : 'hidden';
                const layerNodes = [];
                const nodeSpacing = contentHeight / (layer.neurons.length + 1);
                
                // Add layer label
                g.append('text')
                    .attr('class', 'layer-label')
                    .attr('x', (layerIndex + 1) * layerSpacing)
                    .attr('y', -20)
                    .text(layerType === 'output' ? 'Output Layer' : `Hidden ${layerIndex + 1}`);
                
                // Add nodes for this layer
                layer.neurons.forEach((neuron, neuronIndex) => {
                    const nodeId = `layer${layerIndex}-${neuronIndex}`;
                    const node = {
                        id: nodeId,
                        x: (layerIndex + 1) * layerSpacing,
                        y: (neuronIndex + 1) * nodeSpacing,
                        layer: layerIndex + 1,
                        index: neuronIndex,
                        type: layerType,
                        operation: neuron.operation,
                        // label: `${neuron.operation}`,
                        label: '',
                        value: null
                    };
                    layerNodes.push(node);
                    nodeData.push(node);
                    
                    // Add connections from previous layer
                    neuron.arguments_indexes.forEach(argIndex => {
                        if (argIndex < prevLayerNodes.length) {
                            const sourceNode = prevLayerNodes[argIndex];
                            linkData.push({
                                id: `${sourceNode.id}-to-${nodeId}`,
                                source: sourceNode,
                                target: node,
                                argIndex: argIndex,
                                value: null
                            });
                        }
                    });
                });
                
                prevLayerNodes = layerNodes;
            });
            
            // Create links
            const links = g.selectAll('.link')
                .data(linkData)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('id', d => d.id)
                .attr('d', d => {
                    return `M${d.source.x},${d.source.y} C${(d.source.x + d.target.x) / 2},${d.source.y} `
                        + `${(d.source.x + d.target.x) / 2},${d.target.y} ${d.target.x},${d.target.y}`;
                });
            
            // Create tooltip div
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Create nodes with hover behavior
            const nodes = g.selectAll('.node')
                .data(nodeData)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('id', d => d.id)
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .on('mouseenter', function(event, d) {
                    highlightConnections(d);
                    
                    // Show tooltip
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);
                    
                    let tooltipContent = d.type === 'input' 
                        ? `Input ${d.index}` 
                        : `${d.operation} (Layer ${d.layer}, Node ${d.index})`;
                    
                    tooltip.html(tooltipContent)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseleave', function(event, d) {
                    unhighlightConnections();
                    
                    // Hide tooltip
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);
                });
            
            // Add circles for nodes
            nodes.append('circle')
                .attr('r', 20)
                .attr('class', d => d.type);
            
            // Add text labels for operations
            nodes.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.3em')
                .text(d => d.type === 'input' ? '' : d.operation);
            
            // Add input/output labels
            nodes.append('text')
                .attr('class', 'label')
                .attr('text-anchor', 'middle')
                .attr('dy', '3em')
                .text(d => d.label);
        }

        function setupInputControls(inputSize) {
            const inputControls = document.getElementById('inputControls');
            inputControls.innerHTML = '';
            
            for (let i = 0; i < inputSize; i++) {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                
                const label = document.createElement('label');
                label.htmlFor = `input-${i}-value`;
                label.textContent = `Input ${i}: `;
                
                const select = document.createElement('select');
                select.id = `input-${i}-value`;
                
                const option0 = document.createElement('option');
                option0.value = '0';
                option0.textContent = '0';
                
                const option1 = document.createElement('option');
                option1.value = '1';
                option1.textContent = '1';
                
                select.appendChild(option0);
                select.appendChild(option1);
                
                inputGroup.appendChild(label);
                inputGroup.appendChild(select);
                inputControls.appendChild(inputGroup);
            }
        }

        function runSimulation() {
            resetVisualization();
            
            // Get input values
            const inputValues = [];
            for (let i = 0; i < network.input_size; i++) {
                const value = parseInt(document.getElementById(`input-${i}-value`).value);
                inputValues.push(value);
                
                // Update input node visual based on value (0 or 1)
                const inputNode = nodeData.find(n => n.id === `input-${i}`);
                if (inputNode) {
                    inputNode.value = value;
                    d3.select(`#${inputNode.id} circle`)
                        .classed(value === 1 ? 'active-node-one' : 'active-node-zero', true);
                }
            }
            
            // Process layers sequentially with animation
            processLayersSequentially(inputValues, 0);
        }

        function processLayersSequentially(inputValues, layerIndex) {
            if (layerIndex >= network.layers.length) {
                return; // All layers processed
            }
            
            setTimeout(() => {
                const layerOutputs = evaluateLayer(network.layers[layerIndex], inputValues, layerIndex);
                visualizeLayerOutputs(layerOutputs, layerIndex);
                processLayersSequentially(layerOutputs, layerIndex + 1);
            }, 1000); // 1 second delay between layers
        }

        function evaluateLayer(layer, inputValues, layerIndex) {
            return layer.neurons.map((neuron, neuronIndex) => {
                const value = evaluateNeuron(neuron, inputValues);
                
                // Update node data
                const nodeId = `layer${layerIndex}-${neuronIndex}`;
                const node = nodeData.find(n => n.id === nodeId);
                if (node) {
                    node.value = value;
                }
                
                return value;
            });
        }

        function evaluateNeuron(neuron, inputValues) {
            const args = neuron.arguments_indexes.map(idx => inputValues[idx]);
            
            switch (neuron.operation) {
                case 'And':
                    return args[0] & args[1];
                case 'Or':
                    return args[0] | args[1];
                case 'Not':
                    return args[0] === 0 ? 1 : 0;
                case 'Xor':
                    return args[0] !== args[1] ? 1 : 0;
                case 'NoOp':
                    return args[0];
                default:
                    console.error('Unknown operation:', neuron.operation);
                    return 0;
            }
        }

        function visualizeLayerOutputs(outputs, layerIndex) {
            outputs.forEach((value, neuronIndex) => {
                const nodeId = `layer${layerIndex}-${neuronIndex}`;
                const node = nodeData.find(n => n.id === nodeId);
                
                if (node) {
                    // Highlight node with appropriate class based on value
                    d3.select(`#${nodeId} circle`)
                        .classed(value === 1 ? 'active-node-one' : 'active-node-zero', true);
                    
                    // Highlight incoming links
                    linkData.filter(link => link.target.id === nodeId)
                        .forEach(link => {
                            const sourceValue = link.source.value;
                            const linkElement = d3.select(`#${link.id}`);
                            
                            // Only highlight links where source has a value (0 or 1)
                            if (sourceValue !== null) {
                                linkElement.classed(
                                    sourceValue === 1 ? 'active-link-one' : 'active-link-zero', 
                                    true
                                );
                            }
                        });
                }
            });
        }

        function resetVisualization() {
            // Reset node values
            nodeData.forEach(node => {
                node.value = null;
            });
            
            // Reset visual state (clear both zero and one classes)
            d3.selectAll('.node circle')
                .classed('active-node-one', false)
                .classed('active-node-zero', false);
            
            d3.selectAll('.link')
                .classed('active-link-one', false)
                .classed('active-link-zero', false);
            
            // Also clear any hover highlights
            unhighlightConnections();
        }
        
        // Function to highlight a neuron and its connections
        function highlightConnections(node) {
            // Clear any existing highlights first
            unhighlightConnections();
            
            // Highlight the current node
            d3.select(`#${node.id} circle`).classed('hover-highlight-node', true);
            
            // Find and highlight direct incoming connections and their source nodes
            const incomingLinks = linkData.filter(link => link.target.id === node.id);
            incomingLinks.forEach(link => {
                d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                d3.select(`#${link.source.id} circle`).classed('hover-highlight-related-node', true);
            });
            
            // Find and highlight direct outgoing connections and their target nodes
            const outgoingLinks = linkData.filter(link => link.source.id === node.id);
            outgoingLinks.forEach(link => {
                d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                d3.select(`#${link.target.id} circle`).classed('hover-highlight-related-node', true);
            });
            
            // For backward transitive highlighting (inputs to this node)
            if (node.type !== 'input') {
                // Get all sources that transitively contribute to this node
                const allInputSources = new Set();
                const visitedBackward = new Set();
                
                findAllInputSources(node, allInputSources, visitedBackward);
                
                // Highlight all transitive paths from inputs to this node
                highlightTransitivePathsBackward(node, allInputSources);
            }
            
            // For forward transitive highlighting (this node to outputs)
            if (node.type !== 'output') {
                // Get all output nodes that are transitively influenced by this node
                const allOutputTargets = new Set();
                const visitedForward = new Set();
                
                findAllOutputTargets(node, allOutputTargets, visitedForward);
                
                // Highlight all transitive paths from this node to outputs
                highlightTransitivePathsForward(node, allOutputTargets);
            }
        }
        
        // Recursively find all input sources that contribute to a node
        function findAllInputSources(node, allSources, visited) {
            // Prevent infinite recursion in case of cycles
            if (visited.has(node.id)) return;
            visited.add(node.id);
            
            // Find all direct inputs to this node
            const incomingLinks = linkData.filter(link => link.target.id === node.id);
            
            for (const link of incomingLinks) {
                const sourceNode = link.source;
                
                if (sourceNode.type === 'input') {
                    // This is an input node, add it to our set
                    allSources.add(sourceNode.id);
                } else {
                    // This is an intermediate node, recursively find its inputs
                    findAllInputSources(sourceNode, allSources, visited);
                }
            }
        }
        
        // Recursively find all output targets influenced by a node
        function findAllOutputTargets(node, allTargets, visited) {
            // Prevent infinite recursion in case of cycles
            if (visited.has(node.id)) return;
            visited.add(node.id);
            
            // Find all direct outputs from this node
            const outgoingLinks = linkData.filter(link => link.source.id === node.id);
            
            for (const link of outgoingLinks) {
                const targetNode = link.target;
                
                if (targetNode.type === 'output') {
                    // This is an output node, add it to our set
                    allTargets.add(targetNode.id);
                }
                
                // Always check further connections
                findAllOutputTargets(targetNode, allTargets, visited);
            }
        }
        
        // Highlight all paths from input sources to the target node (backward)
        function highlightTransitivePathsBackward(targetNode, inputSourceIds) {
            // Create a queue for breadth-first traversal
            const queue = [];
            const visited = new Set();
            const highlightedLinks = new Set();
            
            // Start with all input nodes that contribute to the target
            for (const inputId of inputSourceIds) {
                const inputNode = nodeData.find(n => n.id === inputId);
                queue.push(inputNode);
                visited.add(inputId);
                
                // Highlight all input nodes that contribute
                d3.select(`#${inputId} circle`).classed('hover-highlight-related-node', true);
            }
            
            // Breadth-first traversal to highlight all paths to the target
            while (queue.length > 0) {
                const currentNode = queue.shift();
                
                // Find all outgoing links from this node
                const outLinks = linkData.filter(link => link.source.id === currentNode.id);
                
                for (const link of outLinks) {
                    const destNode = link.target;
                    
                    // Only process nodes that can eventually reach the target
                    if (canReachTarget(destNode, targetNode.id, new Set())) {
                        // Highlight this connection
                        d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                        highlightedLinks.add(link.id);
                        
                        // Highlight the destination node
                        d3.select(`#${destNode.id} circle`).classed('hover-highlight-related-node', true);
                        
                        // Add the destination to our queue if not visited
                        if (!visited.has(destNode.id)) {
                            visited.add(destNode.id);
                            queue.push(destNode);
                        }
                    }
                }
            }
        }
        
        // Highlight all paths from the source node to output targets (forward)
        function highlightTransitivePathsForward(sourceNode, outputTargetIds) {
            // Create a queue for breadth-first traversal
            const queue = [];
            const visited = new Set();
            const highlightedLinks = new Set();
            
            // Identify all output nodes that are affected by the source
            const outputNodes = [];
            for (const outputId of outputTargetIds) {
                const outputNode = nodeData.find(n => n.id === outputId);
                outputNodes.push(outputNode);
                
                // Highlight all output nodes that are affected
                d3.select(`#${outputId} circle`).classed('hover-highlight-related-node', true);
            }
            
            // Start with the source node
            queue.push(sourceNode);
            visited.add(sourceNode.id);
            
            // Breadth-first traversal to highlight all paths to outputs
            while (queue.length > 0) {
                const currentNode = queue.shift();
                
                // Find all outgoing links from this node
                const outLinks = linkData.filter(link => link.source.id === currentNode.id);
                
                for (const link of outLinks) {
                    const destNode = link.target;
                    
                    // Only process nodes that lead to our output targets
                    if (canInfluenceAnyOutput(destNode, outputTargetIds, new Set())) {
                        // Highlight this connection
                        d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                        highlightedLinks.add(link.id);
                        
                        // Highlight the destination node
                        d3.select(`#${destNode.id} circle`).classed('hover-highlight-related-node', true);
                        
                        // Add the destination to our queue if not visited
                        if (!visited.has(destNode.id)) {
                            visited.add(destNode.id);
                            queue.push(destNode);
                        }
                    }
                }
            }
        }
        
        // Check if a node can reach the target node
        function canReachTarget(node, targetId, visited) {
            if (node.id === targetId) return true;
            if (visited.has(node.id)) return false;
            
            visited.add(node.id);
            
            // Find all outgoing links from this node
            const outLinks = linkData.filter(link => link.source.id === node.id);
            
            for (const link of outLinks) {
                if (canReachTarget(link.target, targetId, visited)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a node can influence any of the specified output nodes
        function canInfluenceAnyOutput(node, outputIds, visited) {
            if (outputIds.has(node.id)) return true;
            if (visited.has(node.id)) return false;
            
            visited.add(node.id);
            
            // Find all outgoing links from this node
            const outLinks = linkData.filter(link => link.source.id === node.id);
            
            for (const link of outLinks) {
                if (canInfluenceAnyOutput(link.target, outputIds, visited)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Function to remove all highlighting
        function unhighlightConnections() {
            d3.selectAll('.node circle')
                .classed('hover-highlight-node', false)
                .classed('hover-highlight-related-node', false);
            
            d3.selectAll('.link')
                .classed('hover-highlight-link', false);
        }
        
        // Add test data functionality
        let testData = null;
        
        // Sample test data (adder for 3-bit inputs)
        const sampleTestData = {
            "data": [
                {"input": [0, 0, 0], "expected_output": [0, 0]}, 
                {"input": [0, 0, 1], "expected_output": [0, 1]}, 
                {"input": [0, 1, 0], "expected_output": [0, 1]}, 
                {"input": [0, 1, 1], "expected_output": [1, 0]}, 
                {"input": [1, 0, 0], "expected_output": [0, 1]}, 
                {"input": [1, 0, 1], "expected_output": [1, 0]}, 
                {"input": [1, 1, 0], "expected_output": [1, 0]}, 
                {"input": [1, 1, 1], "expected_output": [1, 1]}
            ]
        };
        
        // Add event listeners for test data
        document.getElementById('loadTestDataBtn').addEventListener('click', loadTestData);
        document.getElementById('sampleTestDataBtn').addEventListener('click', loadSampleTestData);
        
        // Add event handler to visualize network button to also validate test data
        document.getElementById('visualizeBtn').addEventListener('click', function() {
            visualizeNetwork();
            if (testData !== null && network !== null) {
                validateTestData();
            }
        });
        
        function loadSampleTestData() {
            document.getElementById('testDataJson').value = JSON.stringify(sampleTestData, null, 2);
            loadTestData();
        }
        
        function loadTestData() {
            const testDataInput = document.getElementById('testDataJson').value;
            try {
                testData = JSON.parse(testDataInput);
                if (network !== null) {
                    validateTestData();
                }
            } catch (error) {
                alert('Error parsing test data JSON: ' + error.message);
            }
        }
        
        function validateTestData() {
            if (!testData || !testData.data || !Array.isArray(testData.data) || testData.data.length === 0) {
                alert('Invalid test data format');
                return;
            }
            
            const tableBody = document.getElementById('validationTableBody');
            tableBody.innerHTML = '';
            
            let correctCount = 0;
            const totalCount = testData.data.length;
            
            // Track confusion matrix values for single output case
            let truePositives = 0;
            let falsePositives = 0;
            let falseNegatives = 0;
            let trueNegatives = 0;
            let isSingleBinaryOutput = true; // Will check if this is a binary single-output classifier
            
            const results = [];
            
            testData.data.forEach((testCase, index) => {
                const row = document.createElement('tr');
                
                // Case number
                const caseCell = document.createElement('td');
                caseCell.textContent = index + 1;
                row.appendChild(caseCell);
                
                // Input values
                const inputCell = document.createElement('td');
                inputCell.textContent = JSON.stringify(testCase.input);
                row.appendChild(inputCell);
                
                // Expected output
                const expectedCell = document.createElement('td');
                expectedCell.textContent = JSON.stringify(testCase.expected_output);
                row.appendChild(expectedCell);
                
                // Calculate actual output
                let actualOutput;
                try {
                    actualOutput = network.evaluate ? 
                        evaluateNetworkForTest(testCase.input) : 
                        calculateNetworkOutput(testCase.input);
                } catch (error) {
                    actualOutput = `Error: ${error.message}`;
                    isSingleBinaryOutput = false; // Error state, can't calculate confusion matrix
                }
                
                // Store results for metrics calculation
                if (Array.isArray(actualOutput) && Array.isArray(testCase.expected_output)) {
                    results.push({
                        expected: testCase.expected_output,
                        actual: actualOutput
                    });
                    
                    // Check if this is a binary single output classifier
                    if (actualOutput.length !== 1 || testCase.expected_output.length !== 1 || 
                        (actualOutput[0] !== 0 && actualOutput[0] !== 1) || 
                        (testCase.expected_output[0] !== 0 && testCase.expected_output[0] !== 1)) {
                        isSingleBinaryOutput = false;
                    }
                    
                    // Update confusion matrix for binary single-output case
                    if (isSingleBinaryOutput) {
                        if (testCase.expected_output[0] === 1) {
                            if (actualOutput[0] === 1) {
                                truePositives++;
                            } else {
                                falseNegatives++;
                            }
                        } else {
                            if (actualOutput[0] === 1) {
                                falsePositives++;
                            } else {
                                trueNegatives++;
                            }
                        }
                    }
                } else {
                    isSingleBinaryOutput = false;
                }
                
                // Actual output
                const actualCell = document.createElement('td');
                actualCell.textContent = JSON.stringify(actualOutput);
                row.appendChild(actualCell);
                
                // Status
                const statusCell = document.createElement('td');
                let isCorrect = false;
                
                if (Array.isArray(actualOutput) && Array.isArray(testCase.expected_output)) {
                    isCorrect = arraysEqual(actualOutput, testCase.expected_output);
                }
                
                if (isCorrect) {
                    statusCell.textContent = '✓';
                    statusCell.classList.add('correct');
                    correctCount++;
                } else {
                    statusCell.textContent = '✗';
                    statusCell.classList.add('error');
                    actualCell.classList.add('error');
                }
                
                row.appendChild(statusCell);
                tableBody.appendChild(row);
            });
            
            // Update summary
            const accuracy = (correctCount / totalCount) * 100;
            document.getElementById('validationSummary').textContent = 
                `Accuracy: ${correctCount}/${totalCount} (${accuracy.toFixed(2)}%)`;
            
            // Update confusion matrix and metrics if this is a binary single-output classifier
            if (isSingleBinaryOutput) {
                document.getElementById('singleOutputMetrics').style.display = 'block';
                
                // Update confusion matrix
                document.getElementById('truePositives').textContent = truePositives;
                document.getElementById('falsePositives').textContent = falsePositives;
                document.getElementById('falseNegatives').textContent = falseNegatives;
                document.getElementById('trueNegatives').textContent = trueNegatives;
                
                // Calculate and update metrics
                const accuracy = (truePositives + trueNegatives) / (truePositives + trueNegatives + falsePositives + falseNegatives);
                const precision = truePositives === 0 ? 0 : truePositives / (truePositives + falsePositives);
                const recall = truePositives === 0 ? 0 : truePositives / (truePositives + falseNegatives);
                const specificity = trueNegatives === 0 ? 0 : trueNegatives / (trueNegatives + falsePositives);
                const f1Score = precision + recall === 0 ? 0 : 2 * (precision * recall) / (precision + recall);
                
                document.getElementById('accuracyMetric').textContent = (accuracy * 100).toFixed(2) + '%';
                document.getElementById('precisionMetric').textContent = (precision * 100).toFixed(2) + '%';
                document.getElementById('recallMetric').textContent = (recall * 100).toFixed(2) + '%';
                document.getElementById('specificityMetric').textContent = (specificity * 100).toFixed(2) + '%';
                document.getElementById('f1ScoreMetric').textContent = f1Score.toFixed(4);
            } else {
                document.getElementById('singleOutputMetrics').style.display = 'none';
            }
            
            // Show validation results
            document.getElementById('validationResults').style.display = 'block';
        }
        
        // Calculate output from the network for test cases
        function calculateNetworkOutput(inputValues) {
            if (!network || !network.layers) {
                throw new Error('No network loaded');
            }
            
            if (inputValues.length !== network.input_size) {
                throw new Error(`Input size mismatch: expected ${network.input_size}, got ${inputValues.length}`);
            }
            
            let currentValues = [...inputValues];
            
            // Process through each layer
            for (let layerIndex = 0; layerIndex < network.layers.length; layerIndex++) {
                const layer = network.layers[layerIndex];
                const layerOutput = [];
                
                for (let neuronIndex = 0; neuronIndex < layer.neurons.length; neuronIndex++) {
                    const neuron = layer.neurons[neuronIndex];
                    const neuronValue = evaluateNeuron(neuron, currentValues);
                    layerOutput.push(neuronValue);
                }
                
                currentValues = layerOutput;
            }
            
            return currentValues;
        }
        
        // Execute the existing evaluate function from the network if it exists
        function evaluateNetworkForTest(inputValues) {
            return network.evaluate(inputValues);
        }
        
        // Helper function to compare arrays
        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
    </script>
</body>
</html>
