<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Signal color variables - easily customizable */
        :root {
            --active-one-color: #f00; /* Red for 1s */
            --active-zero-color: #0066cc; /* Blue for 0s */
            --hover-highlight-color: #ff9900; /* Orange for hover highlight */
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h1, h2 {
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .input-section {
            margin-bottom: 20px;
        }
        #networkJson {
            width: 100%;
            height: 120px;
            font-family: monospace;
            padding: 8px;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .network-visualization {
            width: 100%;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 20px;
            overflow-x: auto;
        }
        #networkGraph {
            min-height: 500px;
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node circle.input {
            fill: #a8d5e5;
        }
        .node circle.hidden {
            fill: #e5d5a8;
        }
        .node circle.output {
            fill: #a8e5c3;
        }
        .node text {
            font-size: 12px;
            font-weight: bold;
        }
        .label {
            font-size: 10px;
            font-style: italic;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        .active-node-one {
            stroke: var(--active-one-color) !important;
            stroke-width: 3px !important;
        }
        .active-node-zero {
            stroke: var(--active-zero-color) !important;
            stroke-width: 3px !important;
        }
        .active-link-one {
            stroke: var(--active-one-color) !important;
            stroke-width: 2.5px !important;
            stroke-opacity: 1 !important;
        }
        .active-link-zero {
            stroke: var(--active-zero-color) !important;
            stroke-width: 2.5px !important;
            stroke-opacity: 1 !important;
        }
        
        .active-node, .active-link {
            display: none;
        }
        .input-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .input-group {
            display: flex;
            align-items: center;
        }
        .value-display {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
        }
        .controls {
            margin: 20px 0;
        }
        .layer-label {
            text-anchor: middle;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Add hover highlight styles */
        .hover-highlight-node {
            stroke: var(--hover-highlight-color) !important;
            stroke-width: 4px !important;
        }
        
        .hover-highlight-link {
            stroke: var(--hover-highlight-color) !important;
            stroke-width: 3px !important;
            stroke-opacity: 0.8 !important;
        }
        
        .hover-highlight-related-node {
            stroke: var(--hover-highlight-color) !important;
            stroke-width: 2px !important;
        }
        
        /* Tooltip for showing neuron info */
        .tooltip {
            position: absolute;
            padding: 6px 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Test data validation table styles */
        .test-data-section {
            margin-top: 30px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        
        #testDataJson {
            width: 100%;
            height: 80px;
            font-family: monospace;
            padding: 8px;
        }
        
        .validation-table {
            margin-top: 20px;
            width: 100%;
            border-collapse: collapse;
        }
        
        .validation-table th, .validation-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        
        .validation-table th {
            background-color: #f2f2f2;
        }
        
        .validation-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .validation-table .error {
            background-color: #ffcccb;
            font-weight: bold;
        }
        
        .validation-table .correct {
            background-color: #d6f5d6;
        }
        
        .validation-summary {
            margin-top: 15px;
            font-weight: bold;
            font-size: 16px;
        }

        /* Confusion matrix styles */
        .confusion-matrix-container {
            margin-top: 20px;
            margin-bottom: 30px;
        }
        
        .confusion-matrix {
            border-collapse: collapse;
            margin: 0 auto;
            text-align: center;
        }
        
        .confusion-matrix th, .confusion-matrix td {
            border: 1px solid #666;
            padding: 10px 15px;
        }
        
        .confusion-matrix th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .confusion-matrix .highlight-cell {
            background-color: #e8e8e8;
        }
        
        .confusion-matrix .true-positive {
            background-color: #d0f0d0;
        }
        
        .confusion-matrix .false-positive {
            background-color: #f8d0d0;
        }
        
        .confusion-matrix .false-negative {
            background-color: #f0e0c0;
        }
        
        .confusion-matrix .true-negative {
            background-color: #d0e0f0;
        }
        
        .metrics-table {
            width: auto;
            margin: 20px auto;
            border-collapse: collapse;
        }
        
        .metrics-table th, .metrics-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        
        .metrics-table th {
            background-color: #f2f2f2;
        }
        
        .single-output-metrics {
            display: none;
        }

        /* Add styles for network statistics */
        .network-stats {
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        
        .stats-table th, .stats-table td {
            padding: 8px 12px;
            border: 1px solid #ddd;
            text-align: center;
        }
        
        .stats-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        
        .stats-table tr.total-row {
            font-weight: bold;
            background-color: #e9e9e9;
        }

        /* Add styles for the code representation */
        .code-representation {
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        pre.code-block {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .code-comment {
            color: #006400;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Neural Network Visualizer</h1>
        
        <div class="input-section">
            <h2>Network Configuration</h2>
            <textarea id="networkJson" placeholder="Paste JSON representation of the network here..."></textarea>
            <div>
                <button id="visualizeBtn">Visualize Network</button>
                <button id="visualizePrunedBtn">Visualize Pruned</button>
                <button id="sampleBtn">Load Sample</button>
            </div>
        </div>
        
        <div id="networkControls" style="display: none;">
            <h2>Network Inputs</h2>
            <div id="inputControls" class="input-controls"></div>
            <div class="controls">
                <button id="runBtn">Run Network</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
        
        <div class="network-visualization">
            <h2>Network Visualization</h2>
            <div id="networkGraph"></div>
            
            <!-- Add Network Statistics Section -->
            <div id="networkStats" class="network-stats" style="display: none;">
                <h3>Network Statistics</h3>
                
                <h4>Neuron Usage</h4>
                <table class="stats-table" id="neuronUsageTable">
                    <thead>
                        <tr>
                            <th>Layer</th>
                            <th>Active Neurons</th>
                            <th>Total Neurons</th>
                            <th>Usage %</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Will be filled dynamically -->
                    </tbody>
                    <tfoot>
                        <tr class="total-row">
                            <td>Total</td>
                            <td id="totalActiveNeurons">0</td>
                            <td id="totalNeurons">0</td>
                            <td id="totalNeuronUsage">0%</td>
                        </tr>
                    </tfoot>
                </table>
                
                <h4>Operation Usage</h4>
                <table class="stats-table" id="operationTable">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Count</th>
                            <th>Percentage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Will be filled dynamically -->
                    </tbody>
                    <tfoot>
                        <tr class="total-row">
                            <td>Useful Operations</td>
                            <td id="usefulOperations">0</td>
                            <td id="usefulOperationsPercentage">0%</td>
                        </tr>
                    </tfoot>
                </table>
            </div>
            
            <!-- Add Code Representation Section -->
            <div id="codeRepresentation" class="code-representation" style="display: none;">
                <h3>Code Representation</h3>
                <p>The network can be represented by the following code:</p>
                <pre id="networkCode" class="code-block">
                    // Code will be generated here
                </pre>
            </div>
        </div>
        
        <!-- Add test data validation section -->
        <div class="test-data-section">
            <h2>Test Data Validation</h2>
            <div class="input-section">
                <textarea id="testDataJson" placeholder="Paste test data JSON here (e.g. {'data': [{'input': [0,0,0], 'expected_output': [0,0]}, ...]}"></textarea>
                <div>
                    <button id="loadTestDataBtn">Load Test Data</button>
                    <button id="sampleTestDataBtn">Load Sample Test Data</button>
                </div>
            </div>
            <div id="validationResults" style="display: none;">
                <h3>Validation Results</h3>
                
                <!-- Add Single-Output Metrics (Confusion Matrix) -->
                <div id="singleOutputMetrics" class="single-output-metrics">
                    <h4>Confusion Matrix</h4>
                    <div class="confusion-matrix-container">
                        <table class="confusion-matrix">
                            <tr>
                                <th colspan="2" rowspan="2"></th>
                                <th colspan="2">Predicted</th>
                            </tr>
                            <tr>
                                <th>Positive (1)</th>
                                <th>Negative (0)</th>
                            </tr>
                            <tr>
                                <th rowspan="2">Actual</th>
                                <th>Positive (1)</th>
                                <td id="truePositives" class="true-positive">0</td>
                                <td id="falseNegatives" class="false-negative">0</td>
                            </tr>
                            <tr>
                                <th>Negative (0)</th>
                                <td id="falsePositives" class="false-positive">0</td>
                                <td id="trueNegatives" class="true-negative">0</td>
                            </tr>
                        </table>
                    </div>
                    
                    <h4>Classification Metrics</h4>
                    <table class="metrics-table">
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>MCC</td>
                            <td id="mccMetric">0</td>
                            <td>(TP×TN - FP×FN) / √((TP+FP)(TP+FN)(TN+FP)(TN+FN))</td>
                        </tr>
                        <tr>
                            <td>Accuracy</td>
                            <td id="accuracyMetric">0%</td>
                            <td>(TP + TN) / Total</td>
                        </tr>
                        <tr>
                            <td>Precision</td>
                            <td id="precisionMetric">0%</td>
                            <td>TP / (TP + FP)</td>
                        </tr>
                        <tr>
                            <td>Recall (Sensitivity)</td>
                            <td id="recallMetric">0%</td>
                            <td>TP / (TP + FN)</td>
                        </tr>
                        <tr>
                            <td>Specificity</td>
                            <td id="specificityMetric">0%</td>
                            <td>TN / (TN + FP)</td>
                        </tr>
                        <tr>
                            <td>F1 Score</td>
                            <td id="f1ScoreMetric">0</td>
                            <td>2 * (Precision * Recall) / (Precision + Recall)</td>
                        </tr>
                    </table>
                </div>
                
                <div class="validation-summary" id="validationSummary"></div>
                <table class="validation-table" id="validationTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Input</th>
                            <th>Expected Output</th>
                            <th>Actual Output</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="validationTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let network = null;
        let nodeData = [];
        let linkData = [];
        let simulationRunning = false;
        let neuronActivationStats = {}; // New: Track neuron activations

        // Sample network JSON
        const sampleNetwork = {
            "input_size": 3,
            "layers": [
                {
                    "input_size": 3,
                    "neurons": [
                        {"operation": "Xor", "arguments_indexes": [0, 1]},
                        {"operation": "NoOp", "arguments_indexes": [1]},
                        {"operation": "Xor", "arguments_indexes": [0, 2]}
                    ]
                },
                {
                    "input_size": 3,
                    "neurons": [
                        {"operation": "Xor", "arguments_indexes": [1, 2]},
                        {"operation": "Or", "arguments_indexes": [0, 2]}
                    ]
                },
                {
                    "input_size": 2,
                    "neurons": [
                        {"operation": "Xor", "arguments_indexes": [0, 1]},
                        {"operation": "NoOp", "arguments_indexes": [0]}
                    ]
                }
            ]
        };

        // Event listeners
        document.getElementById('visualizeBtn').addEventListener('click', visualizeNetwork);
        document.getElementById('visualizePrunedBtn').addEventListener('click', visualizeNetworkPruned);
        document.getElementById('sampleBtn').addEventListener('click', loadSample);
        document.getElementById('runBtn').addEventListener('click', runSimulation);
        document.getElementById('resetBtn').addEventListener('click', resetVisualization);

        function loadSample() {
            document.getElementById('networkJson').value = JSON.stringify(sampleNetwork, null, 2);
        }

        function visualizeNetworkPruned() {
            visualizeNetwork(true);
        }

        function visualizeNetwork(prune = false) {
            // Parse the JSON input
            const jsonInput = document.getElementById('networkJson').value;
            try {
                network = JSON.parse(jsonInput);

                if (prune) {
                    network = pruneNetwork(network);
                }

                renderNetwork(network);
                setupInputControls(network.input_size);
                document.getElementById('networkControls').style.display = 'block';
                
                // Reset neuron activation stats when loading a new network
                neuronActivationStats = {};
                
                // Analyze the network connectivity
                analyzeNetworkConnectivity();
                
                // Generate and display the code representation
                generateCodeRepresentation(network);
            } catch (error) {
                alert('Error parsing JSON: ' + error.message);
            }
        }

        function renderNetwork(network) {
            // Clear previous visualization
            document.getElementById('networkGraph').innerHTML = '';
            
            // Setup dimensions - make width dynamic based on number of layers
            const minWidth = d3.select('#networkGraph').node().getBoundingClientRect().width - 2; // Minimum width
            
            const minWidthPerLayer = 100; // Width per layer
            const totalLayersCount = network.layers.length + 1; // Input layer + hidden/output layers
            
            const widthPerLayer = Math.max(minWidthPerLayer, minWidth / network.layers.length - 30);
            const calculatedWidth = Math.max(minWidth, totalLayersCount * widthPerLayer);

            const width = calculatedWidth;
            
            // Calculate the largest layer size to determine height
            const layerSizes = [network.input_size];
            network.layers.forEach(layer => {
                layerSizes.push(layer.neurons.length);
            });
            const maxLayerSize = Math.max(...layerSizes);
            
            // Set a dynamic height with a minimum of 500px and at least 80px per node
            const minHeight = 500;
            const heightPerNode = 80;
            const calculatedHeight = Math.max(minHeight, maxLayerSize * heightPerNode);
            const height = calculatedHeight;
            
            const margin = { top: 40, right: 50, bottom: 30, left: 50 };
            const contentWidth = width - margin.left - margin.right;
            const contentHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select('#networkGraph')
                .append('svg')
                .attr('width', width - widthPerLayer + 20)
                .attr('height', height);
            
            // Add a group for the network
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);
            
            // Add layer labels
            g.append('text')
                .attr('class', 'layer-label')
                .attr('x', 0)
                .attr('y', -20)
                .text('Input Layer');
                
            // Calculate layers
            const totalLayers = network.layers.length + 1; // Input layer + hidden/output layers
            const layerSpacing = contentWidth / totalLayers;
            
            // Prepare data structures for nodes and links
            nodeData = [];
            linkData = [];
            
            // Add input layer nodes
            const inputNodes = [];
            const inputNodeSpacing = contentHeight / (network.input_size + 1);
            
            for (let i = 0; i < network.input_size; i++) {
                const nodeId = `input-${i}`;
                const node = {
                    id: nodeId,
                    x: 0,
                    y: (i + 1) * inputNodeSpacing,
                    layer: 0,
                    index: i,
                    type: 'input',
                    label: `Input ${i}`,
                    value: null
                };
                inputNodes.push(node);
                nodeData.push(node);
            }
            
            // Process each layer
            let prevLayerNodes = inputNodes;
            
            network.layers.forEach((layer, layerIndex) => {
                const layerType = layerIndex === network.layers.length - 1 ? 'output' : 'hidden';
                const layerNodes = [];
                const nodeSpacing = contentHeight / (layer.neurons.length + 1);
                
                // Add layer label
                g.append('text')
                    .attr('class', 'layer-label')
                    .attr('x', (layerIndex + 1) * layerSpacing)
                    .attr('y', -20)
                    .text(layerType === 'output' ? 'Output Layer' : `Hidden ${layerIndex + 1}`);
                
                // Add nodes for this layer
                layer.neurons.forEach((neuron, neuronIndex) => {
                    const nodeId = `layer${layerIndex}-${neuronIndex}`;
                    const node = {
                        id: nodeId,
                        x: (layerIndex + 1) * layerSpacing,
                        y: (neuronIndex + 1) * nodeSpacing,
                        layer: layerIndex + 1,
                        index: neuronIndex,
                        type: layerType,
                        operation: neuron.operation,
                        // label: `${neuron.operation}`,
                        label: '',
                        value: null
                    };
                    layerNodes.push(node);
                    nodeData.push(node);
                    
                    // Add connections from previous layer
                    neuron.arguments_indexes.forEach(argIndex => {
                        if (argIndex < prevLayerNodes.length) {
                            const sourceNode = prevLayerNodes[argIndex];
                            linkData.push({
                                id: `${sourceNode.id}-to-${nodeId}`,
                                source: sourceNode,
                                target: node,
                                argIndex: argIndex,
                                value: null
                            });
                        }
                    });
                });
                
                prevLayerNodes = layerNodes;
            });
            
            // Create links
            const links = g.selectAll('.link')
                .data(linkData)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('id', d => d.id)
                .attr('d', d => {
                    return `M${d.source.x},${d.source.y} C${(d.source.x + d.target.x) / 2},${d.source.y} `
                        + `${(d.source.x + d.target.x) / 2},${d.target.y} ${d.target.x},${d.target.y}`;
                });
            
            // Create tooltip div
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Create nodes with hover behavior
            const nodes = g.selectAll('.node')
                .data(nodeData)
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('id', d => d.id)
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .on('mouseenter', function(event, d) {
                    highlightConnections(d);
                    
                    // Show tooltip with activation statistics if available
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);
                    
                    let tooltipContent = d.type === 'input' 
                        ? `Input ${d.index}` 
                        : `${d.operation} (Layer ${d.layer}, Node ${d.index})`;
                    
                    // Add activation statistics if available
                    if (neuronActivationStats[d.id]) {
                        const stats = neuronActivationStats[d.id];
                        const total = stats.active + stats.inactive;
                        const activePercent = (stats.active / total * 100).toFixed(1);
                        
                        tooltipContent += `<br>Activation: ${stats.active}/${total} (${activePercent}%)`;
                        tooltipContent += `<br>Cases where output = 1: ${stats.active}`;
                        tooltipContent += `<br>Cases where output = 0: ${stats.inactive}`;
                    }
                    
                    tooltip.html(tooltipContent)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseleave', function(event, d) {
                    unhighlightConnections();
                    
                    // Hide tooltip
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);
                });
            
            // Add circles for nodes
            nodes.append('circle')
                .attr('r', 20)
                .attr('class', d => d.type);
            
            // Add text labels for operations
            nodes.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.3em')
                .text(d => d.type === 'input' ? '' : d.operation);
            
            // Add input/output labels
            nodes.append('text')
                .attr('class', 'label')
                .attr('text-anchor', 'middle')
                .attr('dy', '3em')
                .text(d => d.label);
        }

        function setupInputControls(inputSize) {
            const inputControls = document.getElementById('inputControls');
            inputControls.innerHTML = '';
            
            for (let i = 0; i < inputSize; i++) {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                
                const label = document.createElement('label');
                label.htmlFor = `input-${i}-value`;
                label.textContent = `Input ${i}: `;
                
                const select = document.createElement('select');
                select.id = `input-${i}-value`;
                
                const option0 = document.createElement('option');
                option0.value = '0';
                option0.textContent = '0';
                
                const option1 = document.createElement('option');
                option1.value = '1';
                option1.textContent = '1';
                
                select.appendChild(option0);
                select.appendChild(option1);
                
                inputGroup.appendChild(label);
                inputGroup.appendChild(select);
                inputControls.appendChild(inputGroup);
            }
        }

        function runSimulation() {
            resetVisualization();
            
            // Get input values
            const inputValues = [];
            for (let i = 0; i < network.input_size; i++) {
                const value = parseInt(document.getElementById(`input-${i}-value`).value);
                inputValues.push(value);
                
                // Update input node visual based on value (0 or 1)
                const inputNode = nodeData.find(n => n.id === `input-${i}`);
                if (inputNode) {
                    inputNode.value = value;
                    d3.select(`#${inputNode.id} circle`)
                        .classed(value === 1 ? 'active-node-one' : 'active-node-zero', true);
                }
            }
            
            // Process layers sequentially with animation
            processLayersSequentially(inputValues, 0);
        }

        function processLayersSequentially(inputValues, layerIndex) {
            if (layerIndex >= network.layers.length) {
                // All layers processed - we don't need to do additional analysis here
                // as we're only interested in connectivity, not active neurons during a run
                return;
            }
            
            setTimeout(() => {
                const layerOutputs = evaluateLayer(network.layers[layerIndex], inputValues, layerIndex);
                visualizeLayerOutputs(layerOutputs, layerIndex);
                processLayersSequentially(layerOutputs, layerIndex + 1);
            }, 1000); // 1 second delay between layers
        }

        function evaluateLayer(layer, inputValues, layerIndex) {
            return layer.neurons.map((neuron, neuronIndex) => {
                const value = evaluateNeuron(neuron, inputValues);
                
                // Update node data
                const nodeId = `layer${layerIndex}-${neuronIndex}`;
                const node = nodeData.find(n => n.id === nodeId);
                if (node) {
                    node.value = value;
                }
                
                return value;
            });
        }

        function evaluateNeuron(neuron, inputValues) {
            const args = neuron.arguments_indexes.map(idx => inputValues[idx]);
            
            switch (neuron.operation) {
                case 'And':
                    return args[0] & args[1];
                case 'Or':
                    return args[0] | args[1];
                case 'Not':
                    return args[0] === 0 ? 1 : 0;
                case 'Xor':
                    return args[0] !== args[1] ? 1 : 0;
                case 'NoOp':
                    return args[0];
                default:
                    console.error('Unknown operation:', neuron.operation);
                    return 0;
            }
        }

        function visualizeLayerOutputs(outputs, layerIndex) {
            outputs.forEach((value, neuronIndex) => {
                const nodeId = `layer${layerIndex}-${neuronIndex}`;
                const node = nodeData.find(n => n.id === nodeId);
                
                if (node) {
                    // Highlight node with appropriate class based on value
                    d3.select(`#${nodeId} circle`)
                        .classed(value === 1 ? 'active-node-one' : 'active-node-zero', true);
                    
                    // Highlight incoming links
                    linkData.filter(link => link.target.id === nodeId)
                        .forEach(link => {
                            const sourceValue = link.source.value;
                            const linkElement = d3.select(`#${link.id}`);
                            
                            // Only highlight links where source has a value (0 or 1)
                            if (sourceValue !== null) {
                                linkElement.classed(
                                    sourceValue === 1 ? 'active-link-one' : 'active-link-zero', 
                                    true
                                );
                            }
                        });
                }
            });
        }

        function resetVisualization() {
            // Reset node values
            nodeData.forEach(node => {
                node.value = null;
            });
            
            // Reset visual state (clear both zero and one classes)
            d3.selectAll('.node circle')
                .classed('active-node-one', false)
                .classed('active-node-zero', false)
                .style('opacity', 1.0);  // Reset opacity
            
            d3.selectAll('.link')
                .classed('active-link-one', false)
                .classed('active-link-zero', false)
                .style('opacity', 0.6);  // Reset opacity
            
            // Clear any hover highlights
            unhighlightConnections();
            
            // Run connectivity analysis again to restore connectivity visualization
            analyzeNetworkConnectivity();
        }
        
        // Function to highlight a neuron and its connections
        function highlightConnections(node) {
            // Clear any existing highlights first
            unhighlightConnections();
            
            // Highlight the current node
            d3.select(`#${node.id} circle`).classed('hover-highlight-node', true);
            
            // Find and highlight direct incoming connections and their source nodes
            const incomingLinks = linkData.filter(link => link.target.id === node.id);
            incomingLinks.forEach(link => {
                d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                d3.select(`#${link.source.id} circle`).classed('hover-highlight-related-node', true);
            });
            
            // Find and highlight direct outgoing connections and their target nodes
            const outgoingLinks = linkData.filter(link => link.source.id === node.id);
            outgoingLinks.forEach(link => {
                d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                d3.select(`#${link.target.id} circle`).classed('hover-highlight-related-node', true);
            });
            
            // For backward transitive highlighting (inputs to this node)
            if (node.type !== 'input') {
                // Get all sources that transitively contribute to this node
                const allInputSources = new Set();
                const visitedBackward = new Set();
                
                findAllInputSources(node, allInputSources, visitedBackward);
                
                // Highlight all transitive paths from inputs to this node
                highlightTransitivePathsBackward(node, allInputSources);
            }
            
            // For forward transitive highlighting (this node to outputs)
            if (node.type !== 'output') {
                // Get all output nodes that are transitively influenced by this node
                const allOutputTargets = new Set();
                const visitedForward = new Set();
                
                findAllOutputTargets(node, allOutputTargets, visitedForward);
                
                // Highlight all transitive paths from this node to outputs
                highlightTransitivePathsForward(node, allOutputTargets);
            }
        }
        
        // Recursively find all input sources that contribute to a node
        function findAllInputSources(node, allSources, visited) {
            // Prevent infinite recursion in case of cycles
            if (visited.has(node.id)) return;
            visited.add(node.id);
            
            // Find all direct inputs to this node
            const incomingLinks = linkData.filter(link => link.target.id === node.id);
            
            for (const link of incomingLinks) {
                const sourceNode = link.source;
                
                if (sourceNode.type === 'input') {
                    // This is an input node, add it to our set
                    allSources.add(sourceNode.id);
                } else {
                    // This is an intermediate node, recursively find its inputs
                    findAllInputSources(sourceNode, allSources, visited);
                }
            }
        }
        
        // Recursively find all output targets influenced by a node
        function findAllOutputTargets(node, allTargets, visited) {
            // Prevent infinite recursion in case of cycles
            if (visited.has(node.id)) return;
            visited.add(node.id);
            
            // Find all direct outputs from this node
            const outgoingLinks = linkData.filter(link => link.source.id === node.id);
            
            for (const link of outgoingLinks) {
                const targetNode = link.target;
                
                if (targetNode.type === 'output') {
                    // This is an output node, add it to our set
                    allTargets.add(targetNode.id);
                }
                
                // Always check further connections
                findAllOutputTargets(targetNode, allTargets, visited);
            }
        }
        
        // Highlight all paths from input sources to the target node (backward)
        function highlightTransitivePathsBackward(targetNode, inputSourceIds) {
            // Create a queue for breadth-first traversal
            const queue = [];
            const visited = new Set();
            const highlightedLinks = new Set();
            
            // Start with all input nodes that contribute to the target
            for (const inputId of inputSourceIds) {
                const inputNode = nodeData.find(n => n.id === inputId);
                queue.push(inputNode);
                visited.add(inputId);
                
                // Highlight all input nodes that contribute
                d3.select(`#${inputId} circle`).classed('hover-highlight-related-node', true);
            }
            
            // Breadth-first traversal to highlight all paths to the target
            while (queue.length > 0) {
                const currentNode = queue.shift();
                
                // Find all outgoing links from this node
                const outLinks = linkData.filter(link => link.source.id === currentNode.id);
                
                for (const link of outLinks) {
                    const destNode = link.target;
                    
                    // Only process nodes that can eventually reach the target
                    if (canReachTarget(destNode, targetNode.id, new Set())) {
                        // Highlight this connection
                        d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                        highlightedLinks.add(link.id);
                        
                        // Highlight the destination node
                        d3.select(`#${destNode.id} circle`).classed('hover-highlight-related-node', true);
                        
                        // Add the destination to our queue if not visited
                        if (!visited.has(destNode.id)) {
                            visited.add(destNode.id);
                            queue.push(destNode);
                        }
                    }
                }
            }
        }
        
        // Highlight all paths from the source node to output targets (forward)
        function highlightTransitivePathsForward(sourceNode, outputTargetIds) {
            // Create a queue for breadth-first traversal
            const queue = [];
            const visited = new Set();
            const highlightedLinks = new Set();
            
            // Identify all output nodes that are affected by the source
            const outputNodes = [];
            for (const outputId of outputTargetIds) {
                const outputNode = nodeData.find(n => n.id === outputId);
                outputNodes.push(outputNode);
                
                // Highlight all output nodes that are affected
                d3.select(`#${outputId} circle`).classed('hover-highlight-related-node', true);
            }
            
            // Start with the source node
            queue.push(sourceNode);
            visited.add(sourceNode.id);
            
            // Breadth-first traversal to highlight all paths to outputs
            while (queue.length > 0) {
                const currentNode = queue.shift();
                
                // Find all outgoing links from this node
                const outLinks = linkData.filter(link => link.source.id === currentNode.id);
                
                for (const link of outLinks) {
                    const destNode = link.target;
                    
                    // Only process nodes that lead to our output targets
                    if (canInfluenceAnyOutput(destNode, outputTargetIds, new Set())) {
                        // Highlight this connection
                        d3.select(`#${link.id}`).classed('hover-highlight-link', true);
                        highlightedLinks.add(link.id);
                        
                        // Highlight the destination node
                        d3.select(`#${destNode.id} circle`).classed('hover-highlight-related-node', true);
                        
                        // Add the destination to our queue if not visited
                        if (!visited.has(destNode.id)) {
                            visited.add(destNode.id);
                            queue.push(destNode);
                        }
                    }
                }
            }
        }
        
        // Check if a node can reach the target node
        function canReachTarget(node, targetId, visited) {
            if (node.id === targetId) return true;
            if (visited.has(node.id)) return false;
            
            visited.add(node.id);
            
            // Find all outgoing links from this node
            const outLinks = linkData.filter(link => link.source.id === node.id);
            
            for (const link of outLinks) {
                if (canReachTarget(link.target, targetId, visited)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a node can influence any of the specified output nodes
        function canInfluenceAnyOutput(node, outputIds, visited) {
            if (outputIds.has(node.id)) return true;
            if (visited.has(node.id)) return false;
            
            visited.add(node.id);
            
            // Find all outgoing links from this node
            const outLinks = linkData.filter(link => link.source.id === node.id);
            
            for (const link of outLinks) {
                if (canInfluenceAnyOutput(link.target, outputIds, visited)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function pruneNetwork(network) {
            console.log('Pruning network...');
            // Create a deep copy of the original network
            const originalNetwork = JSON.parse(JSON.stringify(network));
            
            // Identify neurons that are structurally connected to outputs
            const connectedNeurons = {};
            
            // Initialize connectivity tracking for each layer
            for (let i = 0; i < originalNetwork.layers.length; i++) {
                connectedNeurons[i] = new Set();
            }
            
            // Start with output neurons (the last layer) - mark all as connected
            const outputLayerIndex = originalNetwork.layers.length - 1;
            for (let i = 0; i < originalNetwork.layers[outputLayerIndex].neurons.length; i++) {
                connectedNeurons[outputLayerIndex].add(i);
            }
            
            // Trace backward from outputs to inputs to find connected neurons
            for (let layerIndex = outputLayerIndex; layerIndex > 0; layerIndex--) {
                const layer = originalNetwork.layers[layerIndex];
                const prevLayerIndex = layerIndex - 1;
                
                // For each connected neuron in this layer
                connectedNeurons[layerIndex].forEach(neuronIndex => {
                    const neuron = layer.neurons[neuronIndex];
                    
                    // Mark all input sources to this neuron as connected
                    neuron.arguments_indexes.forEach(argIndex => {
                        connectedNeurons[prevLayerIndex].add(argIndex);
                    });
                });
            }
            
            // Create the pruned network structure
            const prunedNetwork = {
                input_size: originalNetwork.input_size, // Keep original input size
                layers: []
            };
            
            // Keep track of index mappings from original to pruned network
            const indexMappings = {};
            
            // Process each layer to build the pruned network
            for (let layerIndex = 0; layerIndex < originalNetwork.layers.length; layerIndex++) {
                const originalLayer = originalNetwork.layers[layerIndex];
                const newLayer = {
                    input_size: layerIndex === 0 ? originalNetwork.input_size : prunedNetwork.layers[layerIndex - 1].neurons.length,
                    neurons: []
                };
                
                // Create mapping from original indices to new indices
                indexMappings[layerIndex] = {};
                let newIndex = 0;
                
                // For each neuron in this layer
                for (let i = 0; i < originalLayer.neurons.length; i++) {
                    // Only include if it's connected to outputs
                    if (connectedNeurons[layerIndex].has(i)) {
                        // Record the mapping of original index to new index
                        indexMappings[layerIndex][i] = newIndex++;
                        
                        // Clone the neuron
                        const originalNeuron = originalLayer.neurons[i];
                        const newNeuron = {
                            operation: originalNeuron.operation,
                            arguments_indexes: [...originalNeuron.arguments_indexes]
                        };
                        
                        // Remap argument indexes for non-first layers
                        if (layerIndex > 0) {
                            newNeuron.arguments_indexes = newNeuron.arguments_indexes.map(argIdx => 
                                indexMappings[layerIndex - 1][argIdx] || 0); // Fallback to prevent errors
                        }
                        
                        newLayer.neurons.push(newNeuron);
                    }
                }
                
                prunedNetwork.layers.push(newLayer);
            }
            
            return prunedNetwork;
        }

        // Function to remove all highlighting
        function unhighlightConnections() {
            d3.selectAll('.node circle')
                .classed('hover-highlight-node', false)
                .classed('hover-highlight-related-node', false);
            
            d3.selectAll('.link')
                .classed('hover-highlight-link', false);
        }
        
        // Add test data functionality
        let testData = null;
        
        // Sample test data (adder for 3-bit inputs)
        const sampleTestData = {
            "data": [
                {"input": [0, 0, 0], "expected_output": [0, 0]}, 
                {"input": [0, 0, 1], "expected_output": [0, 1]}, 
                {"input": [0, 1, 0], "expected_output": [0, 1]}, 
                {"input": [0, 1, 1], "expected_output": [1, 0]}, 
                {"input": [1, 0, 0], "expected_output": [0, 1]}, 
                {"input": [1, 0, 1], "expected_output": [1, 0]}, 
                {"input": [1, 1, 0], "expected_output": [1, 0]}, 
                {"input": [1, 1, 1], "expected_output": [1, 1]}
            ]
        };
        
        // Add event listeners for test data
        document.getElementById('loadTestDataBtn').addEventListener('click', loadTestData);
        document.getElementById('sampleTestDataBtn').addEventListener('click', loadSampleTestData);
        
        // Add event handler to visualize network button to also validate test data
        document.getElementById('visualizeBtn').addEventListener('click', function() {
            visualizeNetwork();
            if (testData !== null && network !== null) {
                validateTestData();
            }
        });
        
        function loadSampleTestData() {
            document.getElementById('testDataJson').value = JSON.stringify(sampleTestData, null, 2);
            loadTestData();
        }
        
        function loadTestData() {
            const testDataInput = document.getElementById('testDataJson').value;
            try {
                testData = JSON.parse(testDataInput);
                if (network !== null) {
                    validateTestData();
                }
            } catch (error) {
                alert('Error parsing test data JSON: ' + error.message);
            }
        }
        
        function validateTestData() {
            if (!testData || !testData.data || !Array.isArray(testData.data) || testData.data.length === 0) {
                alert('Invalid test data format');
                return;
            }
            
            // Reset neuron activation statistics
            neuronActivationStats = {};
            
            const tableBody = document.getElementById('validationTableBody');
            tableBody.innerHTML = '';
            
            let correctCount = 0;
            const totalCount = testData.data.length;
            
            // Track confusion matrix values for single output case
            let truePositives = 0;
            let falsePositives = 0;
            let falseNegatives = 0;
            let trueNegatives = 0;
            let isSingleBinaryOutput = true; // Will check if this is a binary single-output classifier
            
            const results = [];
            
            testData.data.forEach((testCase, index) => {
                const row = document.createElement('tr');
                
                // Case number
                const caseCell = document.createElement('td');
                caseCell.textContent = index + 1;
                row.appendChild(caseCell);
                
                // Input values
                const inputCell = document.createElement('td');
                inputCell.textContent = JSON.stringify(testCase.input);
                row.appendChild(inputCell);
                
                // Expected output
                const expectedCell = document.createElement('td');
                expectedCell.textContent = JSON.stringify(testCase.expected_output);
                row.appendChild(expectedCell);
                
                // Calculate actual output
                let actualOutput;
                try {
                    // Track neuron activations during this test case
                    actualOutput = calculateNetworkOutputWithStats(testCase.input);
                } catch (error) {
                    actualOutput = `Error: ${error.message}`;
                    isSingleBinaryOutput = false; // Error state, can't calculate confusion matrix
                }
                
                // Store results for metrics calculation
                if (Array.isArray(actualOutput) && Array.isArray(testCase.expected_output)) {
                    results.push({
                        expected: testCase.expected_output,
                        actual: actualOutput
                    });
                    
                    // Check if this is a binary single output classifier
                    if (actualOutput.length !== 1 || testCase.expected_output.length !== 1 || 
                        (actualOutput[0] !== 0 && actualOutput[0] !== 1) || 
                        (testCase.expected_output[0] !== 0 && testCase.expected_output[0] !== 1)) {
                        isSingleBinaryOutput = false;
                    }
                    
                    // Update confusion matrix for binary single-output case
                    if (isSingleBinaryOutput) {
                        if (testCase.expected_output[0] === 1) {
                            if (actualOutput[0] === 1) {
                                truePositives++;
                            } else {
                                falseNegatives++;
                            }
                        } else {
                            if (actualOutput[0] === 1) {
                                falsePositives++;
                            } else {
                                trueNegatives++;
                            }
                        }
                    }
                } else {
                    isSingleBinaryOutput = false;
                }
                
                // Actual output
                const actualCell = document.createElement('td');
                actualCell.textContent = JSON.stringify(actualOutput);
                row.appendChild(actualCell);
                
                // Status
                const statusCell = document.createElement('td');
                let isCorrect = false;
                
                if (Array.isArray(actualOutput) && Array.isArray(testCase.expected_output)) {
                    isCorrect = arraysEqual(actualOutput, testCase.expected_output);
                }
                
                if (isCorrect) {
                    statusCell.textContent = '✓';
                    statusCell.classList.add('correct');
                    correctCount++;
                } else {
                    statusCell.textContent = '✗';
                    statusCell.classList.add('error');
                    actualCell.classList.add('error');
                }
                
                row.appendChild(statusCell);
                tableBody.appendChild(row);
            });
            
            // Update summary
            const accuracy = (correctCount / totalCount) * 100;
            document.getElementById('validationSummary').textContent = 
                `Accuracy: ${correctCount}/${totalCount} (${accuracy.toFixed(2)}%)`;
            
            // Update confusion matrix and metrics if this is a binary single-output classifier
            if (isSingleBinaryOutput) {
                document.getElementById('singleOutputMetrics').style.display = 'block';
                
                // Update confusion matrix
                document.getElementById('truePositives').textContent = truePositives;
                document.getElementById('falsePositives').textContent = falsePositives;
                document.getElementById('falseNegatives').textContent = falseNegatives;
                document.getElementById('trueNegatives').textContent = trueNegatives;
                
                // Calculate and update metrics
                const accuracy = (truePositives + trueNegatives) / (truePositives + trueNegatives + falsePositives + falseNegatives);
                const precision = truePositives === 0 ? 0 : truePositives / (truePositives + falsePositives);
                const recall = truePositives === 0 ? 0 : truePositives / (truePositives + falseNegatives);
                const specificity = trueNegatives === 0 ? 0 : trueNegatives / (trueNegatives + falsePositives);
                const f1Score = precision + recall === 0 ? 0 : 2 * (precision * recall) / (precision + recall);
                
                // Calculate Matthews Correlation Coefficient (MCC)
                const numerator = truePositives * trueNegatives - falsePositives * falseNegatives;
                const denominator = Math.sqrt(
                    (truePositives + falsePositives) * 
                    (truePositives + falseNegatives) * 
                    (trueNegatives + falsePositives) * 
                    (trueNegatives + falseNegatives)
                ) || 1; // Avoid division by zero
                const mcc = numerator / denominator;
                
                document.getElementById('accuracyMetric').textContent = (accuracy * 100).toFixed(2) + '%';
                document.getElementById('precisionMetric').textContent = (precision * 100).toFixed(2) + '%';
                document.getElementById('recallMetric').textContent = (recall * 100).toFixed(2) + '%';
                document.getElementById('specificityMetric').textContent = (specificity * 100).toFixed(2) + '%';
                document.getElementById('f1ScoreMetric').textContent = f1Score.toFixed(4);
                document.getElementById('mccMetric').textContent = mcc.toFixed(4);
            } else {
                document.getElementById('singleOutputMetrics').style.display = 'none';
            }
            
            // Show validation results
            document.getElementById('validationResults').style.display = 'block';
        }
        
        // Calculate output from the network for test cases
        function calculateNetworkOutput(inputValues) {
            return calculateNetworkOutputWithStats(inputValues);
        }
        
        // New function to calculate output while tracking activations
        function calculateNetworkOutputWithStats(inputValues) {
            if (!network || !network.layers) {
                throw new Error('No network loaded');
            }
            
            if (inputValues.length !== network.input_size) {
                throw new Error(`Input size mismatch: expected ${network.input_size}, got ${inputValues.length}`);
            }
            
            let currentValues = [...inputValues];
            
            // Track input node activations
            for (let i = 0; i < inputValues.length; i++) {
                const nodeId = `input-${i}`;
                
                if (!neuronActivationStats[nodeId]) {
                    neuronActivationStats[nodeId] = { active: 0, inactive: 0 };
                }
                
                if (inputValues[i] === 1) {
                    neuronActivationStats[nodeId].active++;
                } else {
                    neuronActivationStats[nodeId].inactive++;
                }
            }
            
            // Process through each layer
            for (let layerIndex = 0; layerIndex < network.layers.length; layerIndex++) {
                const layer = network.layers[layerIndex];
                const layerOutput = [];
                
                for (let neuronIndex = 0; neuronIndex < layer.neurons.length; neuronIndex++) {
                    const neuron = layer.neurons[neuronIndex];
                    const neuronValue = evaluateNeuron(neuron, currentValues);
                    layerOutput.push(neuronValue);
                    
                    // Track neuron activation
                    const nodeId = `layer${layerIndex}-${neuronIndex}`;
                    
                    if (!neuronActivationStats[nodeId]) {
                        neuronActivationStats[nodeId] = { active: 0, inactive: 0 };
                    }
                    
                    if (neuronValue === 1) {
                        neuronActivationStats[nodeId].active++;
                    } else {
                        neuronActivationStats[nodeId].inactive++;
                    }
                }
                
                currentValues = layerOutput;
            }
            
            return currentValues;
        }
        
        // Helper function to compare arrays
        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        // New function to analyze network connectivity
        function analyzeNetworkConnectivity() {
            // Identify neurons that are structurally connected to outputs
            const connectedNeurons = new Set();
            const connectedOperations = {};
            
            // Start with output neurons and work backward
            const outputLayerIndex = network.layers.length - 1;
            const outputNodes = nodeData.filter(node => node.layer === outputLayerIndex + 1);
            
            // BFS queue to traverse the network backward
            const queue = [...outputNodes];
            
            // Mark all output neurons as connected
            outputNodes.forEach(node => {
                connectedNeurons.add(node.id);
                
                // Count operations
                if (!connectedOperations[node.operation]) {
                    connectedOperations[node.operation] = 0;
                }
                connectedOperations[node.operation]++;
            });
            
            // Find all neurons that can potentially contribute to output
            while (queue.length > 0) {
                const currentNode = queue.shift();
                
                // Find all incoming links (neurons that feed into this one)
                const incomingLinks = linkData.filter(link => link.target.id === currentNode.id);
                
                for (const link of incomingLinks) {
                    const sourceNode = nodeData.find(node => node.id === link.source.id);
                    
                    // If this source is already counted, skip it
                    if (connectedNeurons.has(sourceNode.id)) continue;
                    
                    // Mark source as connected to output path
                    connectedNeurons.add(sourceNode.id);
                    
                    // Track operations if it's not an input node
                    if (sourceNode.type !== 'input') {
                        if (!connectedOperations[sourceNode.operation]) {
                            connectedOperations[sourceNode.operation] = 0;
                        }
                        connectedOperations[sourceNode.operation]++;
                        
                        // Add to queue to continue tracing backward
                        queue.push(sourceNode);
                    }
                }
            }
            
            // Gather statistics on connected vs. total neurons
            const layerStats = {};
            let totalNeurons = 0;
            let totalConnected = 0;
            
            // Count input nodes
            const inputNodes = nodeData.filter(n => n.type === 'input');
            const connectedInputs = inputNodes.filter(n => connectedNeurons.has(n.id));
            layerStats['Input'] = {
                total: inputNodes.length,
                connected: connectedInputs.length
            };
            totalNeurons += inputNodes.length;
            totalConnected += connectedInputs.length;
            
            // Count neurons per hidden layer
            network.layers.forEach((layer, index) => {
                const isOutputLayer = index === network.layers.length - 1;
                const layerName = isOutputLayer ? 'Output' : `Hidden ${index + 1}`;
                
                const layerNodes = nodeData.filter(n => n.layer === index + 1);
                const connectedLayerNodes = layerNodes.filter(n => connectedNeurons.has(n.id));
                
                layerStats[layerName] = {
                    total: layerNodes.length,
                    connected: connectedLayerNodes.length
                };
                
                totalNeurons += layerNodes.length;
                totalConnected += connectedLayerNodes.length;
            });
            
            // Count total operations (all operations in the network)
            const allOperations = {};
            network.layers.forEach(layer => {
                layer.neurons.forEach(neuron => {
                    if (!allOperations[neuron.operation]) {
                        allOperations[neuron.operation] = 0;
                    }
                    allOperations[neuron.operation]++;
                });
            });
            
            // Display the connectivity statistics
            updateNetworkConnectivityStats(connectedNeurons, connectedOperations, layerStats, totalConnected, totalNeurons, allOperations);
            
            // Also visualize the connectivity in the graph
            visualizeConnectivity(connectedNeurons);
        }
        
        // Update tables with connectivity statistics
        function updateNetworkConnectivityStats(connectedNeurons, connectedOperations, layerStats, totalConnected, totalNeurons, allOperations) {
            // Show the statistics container
            document.getElementById('networkStats').style.display = 'block';
            
            // Update the neuron usage table
            const usageTable = document.getElementById('neuronUsageTable');
            const usageTableBody = usageTable.querySelector('tbody');
            usageTableBody.innerHTML = '';
            
            // Add rows for each layer
            Object.entries(layerStats).forEach(([layerName, stats]) => {
                const percentage = (stats.connected / stats.total * 100).toFixed(1);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${layerName}</td>
                    <td>${stats.connected}</td>
                    <td>${stats.total}</td>
                    <td>${percentage}%</td>
                `;
                usageTableBody.appendChild(row);
            });
            
            // Update totals
            document.getElementById('totalActiveNeurons').textContent = totalConnected;
            document.getElementById('totalNeurons').textContent = totalNeurons;
            document.getElementById('totalNeuronUsage').textContent = 
                (totalConnected / totalNeurons * 100).toFixed(1) + '%';
            
            // Update the operation table
            const operationTable = document.getElementById('operationTable');
            const operationTableBody = operationTable.querySelector('tbody');
            operationTableBody.innerHTML = '';
            
            // Calculate total operations and useful operations
            let totalOperationsCount = 0;
            let totalConnectedOperationsCount = 0;
            let noOpCount = 0;
            let connectedNoOpCount = 0;
            
            for (const op in allOperations) {
                totalOperationsCount += allOperations[op];
                if (op === 'NoOp') {
                    noOpCount = allOperations[op];
                }
            }
            
            for (const op in connectedOperations) {
                totalConnectedOperationsCount += connectedOperations[op];
                if (op === 'NoOp') {
                    connectedNoOpCount = connectedOperations[op];
                }
            }
            
            // Sort operations alphabetically but with NoOp last
            const sortedOperations = Object.keys(allOperations).sort((a, b) => {
                if (a === 'NoOp') return 1;
                if (b === 'NoOp') return -1;
                return a.localeCompare(b);
            });
            
            // Add rows for each operation
            sortedOperations.forEach(op => {
                const totalCount = allOperations[op] || 0;
                const connectedCount = connectedOperations[op] || 0;
                const percentage = (connectedCount / totalCount * 100).toFixed(1);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${op}</td>
                    <td>${connectedCount}/${totalCount}</td>
                    <td>${percentage}%</td>
                `;
                operationTableBody.appendChild(row);
            });
            
            // Update useful operations (total minus NoOp)
            const totalUsefulOps = totalOperationsCount - noOpCount;
            const connectedUsefulOps = totalConnectedOperationsCount - connectedNoOpCount;
            
            document.getElementById('usefulOperations').textContent = `${connectedUsefulOps}/${totalUsefulOps}`;
            document.getElementById('usefulOperationsPercentage').textContent = 
                (connectedUsefulOps / totalUsefulOps * 100).toFixed(1) + '%';
        }
        
        // Visually highlight connected neurons in the graph
        function visualizeConnectivity(connectedNeurons) {
            // Visually distinguish connected vs unconnected neurons
            nodeData.forEach(node => {
                const isConnected = connectedNeurons.has(node.id);
                const nodeElement = d3.select(`#${node.id} circle`);
                
                if (isConnected) {
                    nodeElement.style('opacity', 1.0);
                } else {
                    // Fade out disconnected neurons
                    nodeElement.style('opacity', 0.4);
                }
            });
            
            // Also update links
            linkData.forEach(link => {
                const isConnected = connectedNeurons.has(link.target.id) && 
                                   connectedNeurons.has(link.source.id);
                const linkElement = d3.select(`#${link.id}`);
                
                if (isConnected) {
                    linkElement.style('opacity', 0.6);
                } else {
                    linkElement.style('opacity', 0.2);
                }
            });
        }

        // Function to generate code representation of the network
        function generateCodeRepresentation(network) {
            // Always use a pruned network for the code representation to keep it clean
            const prunedNetwork = pruneNetwork(network);
            
            // Start building the code
            let code = "";
            
            // Add comment header
            code += "# Neural Network Code Representation\n";
            code += "# Using pruned network with only connected neurons\n\n";
            
            // Define inputs
            code += "# Input variables\n";
            for (let i = 0; i < prunedNetwork.input_size; i++) {
                code += `i${i + 1} # Input ${i}\n`;
            }
            code += "\n";
            
            // Define operations for each layer
            prunedNetwork.layers.forEach((layer, layerIndex) => {
                const isOutputLayer = layerIndex === prunedNetwork.layers.length - 1;
                const prefix = isOutputLayer ? "o" : `h${layerIndex + 1}_`;
                
                // Add layer comment
                if (isOutputLayer) {
                    code += "# Output layer\n";
                } else {
                    code += `# Hidden layer ${layerIndex + 1}\n`;
                }
                
                // Process each neuron in the layer
                layer.neurons.forEach((neuron, neuronIndex) => {
                    const variableName = isOutputLayer ? `${prefix}${neuronIndex + 1}` : `${prefix}${neuronIndex}`;
                    
                    // Format the operation
                    let operation;
                    const args = neuron.arguments_indexes.map(idx => {
                        // Determine the variable name for this argument
                        if (layerIndex === 0) {
                            // First hidden layer references inputs
                            return `i${idx + 1}`;
                        } else {
                            // Other layers reference previous layer neurons
                            const prevLayerPrefix = layerIndex === 1 ? "h1_" : `h${layerIndex}_`;
                            return `${prevLayerPrefix}${idx}`;
                        }
                    });
                    
                    // Format the operation based on operation type
                    switch (neuron.operation) {
                        case "And":
                            operation = `${args[0]} & ${args[1]}`;
                            break;
                        case "Or":
                            operation = `${args[0]} | ${args[1]}`;
                            break;
                        case "Xor":
                            operation = `${args[0]} ^ ${args[1]}`;
                            break;
                        case "Not":
                            operation = `~${args[0]}`;
                            break;
                        case "NoOp":
                            operation = args[0];
                            break;
                        default:
                            operation = `unknown_op(${args.join(", ")})`;
                    }
                    
                    // Write the operation
                    code += `${variableName} = ${operation}\n`;
                });
                
                code += "\n";
            });
            
            // Display the code
            document.getElementById('networkCode').textContent = code;
            document.getElementById('codeRepresentation').style.display = 'block';
        }
    </script>
</body>
</html>
